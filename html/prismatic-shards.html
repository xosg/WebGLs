<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Prismatic Shards</title>
  <style>
    html, body { margin: 0; height: 100%; background: #0e1217; }
    canvas { display: block; width: 100vw; height: 100vh; }
  </style>
</head>
<body>
  <canvas id="fx"></canvas>

  <script id="vs" type="x-shader/x-vertex">
    attribute vec3 position; attribute vec2 uv; varying vec2 vUv;
    void main(){ vUv = uv; gl_Position = vec4(position,1.0); }
  </script>

  <script id="fs" type="x-shader/x-fragment">
    #ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    #else
    precision mediump float;
    #endif
    varying vec2 vUv; uniform vec2 resolution; uniform float time;

    // Tiny hash and site position; no noise, minimal math
    float h12(vec2 p){ return fract(sin(dot(p, vec2(41.3,289.1))) * 43758.5453); }
    vec2 site(float i, float t){ float a=t*(0.22+0.01*i)+6.28318*h12(vec2(i, i+7.)); float r=0.25+0.18*sin(i*1.9+t*0.5); return 0.5 + r*vec2(cos(a), sin(a*1.27+i*0.37)); }

    void main(){
      vec2 uv = vUv; float t = mod(time, 628.3185307);
      float px = 1.0 / max(resolution.y, 1.0);

      // Voronoi: nearest and second nearest
      float d1=1e9, d2=1e9, id1=-1.0; vec2 to1=vec2(0.0);
      const int N=16; // fewer sites -> faster
      for(int k=0;k<N;k++){
        float i=float(k); vec2 p=site(i,t); vec2 v=uv-p; float d=dot(v,v);
        if(d<d1){ d2=d1; d1=d; to1=v; id1=i; } else if(d<d2){ d2=d; }
      }
      d1=sqrt(d1); d2=sqrt(d2);

      // Edge factor and bevel normal
      float edge = 1.0 - smoothstep(0.0, 2.0*px, d2-d1);
      vec2 g = normalize(-to1 + 1e-6);
      vec3 n = normalize(vec3(g, 0.6));

      // Lighting (single light + view)
      vec3 l = normalize(vec3(0.4,0.7,0.6));
      float ndl = max(dot(n,l),0.0);
      float spec = pow(max(dot(n, normalize(l+vec3(0,0,1))),0.0), 80.0);

      // Background gradient
      vec3 base = mix(vec3(0.02,0.03,0.05), vec3(0.10,0.13,0.18), smoothstep(0.0,1.0,uv.y));

      // Face color + prismatic edge using angle hue
      float ang = atan(g.y, g.x) / 6.28318 + t*0.02;
      vec3 prism = 0.5 + 0.5*cos(6.28318*(ang + vec3(0.0,0.33,0.67)));
      vec3 face = mix(vec3(0.72,0.78,0.86), vec3(0.82,0.88,0.96), ndl) + vec3(1.0)*spec*0.9;
      vec3 col = mix(face, prism, edge*0.9);
      col = mix(base, col, 0.9);

      // Thin outline and mild vignette
      float outline = smoothstep(1.5*px, 0.3*px, d2-d1);
      col = mix(col, vec3(0.98), 0.08*outline);
      float ar = resolution.x / max(resolution.y, 1.0); vec2 q=(uv-0.5)*vec2(ar,1.0); col *= mix(0.86,1.0, 1.0 - smoothstep(0.6,1.05,length(q)));
      gl_FragColor = vec4(col,1.0);
    }
  </script>

  <script>
    const canvas = document.getElementById('fx');
    const gl = canvas.getContext('webgl');
    if(!gl){ alert('WebGL not supported'); throw new Error('WebGL not supported'); }

    function createShader(type, source){
      const sh = gl.createShader(type);
      gl.shaderSource(sh, source);
      gl.compileShader(sh);
      if(!gl.getShaderParameter(sh, gl.COMPILE_STATUS)){
        console.error(gl.getShaderInfoLog(sh));
        throw new Error('Shader compile failed');
      }
      return sh;
    }

    const vs = createShader(gl.VERTEX_SHADER, document.getElementById('vs').textContent);
    const fs = createShader(gl.FRAGMENT_SHADER, document.getElementById('fs').textContent);
    const program = gl.createProgram(); gl.attachShader(program, vs); gl.attachShader(program, fs); gl.linkProgram(program);
    if(!gl.getProgramParameter(program, gl.LINK_STATUS)){
      console.error(gl.getProgramInfoLog(program)); throw new Error('Program link failed');
    }

    const positions = new Float32Array([ -1,-1,0, 1,-1,0, -1,1,0, 1,1,0 ]);
    const uvs = new Float32Array([ 0,0, 1,0, 0,1, 1,1 ]);
    const posBuf = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, posBuf); gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);
    const uvBuf  = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, uvBuf);  gl.bufferData(gl.ARRAY_BUFFER, uvs, gl.STATIC_DRAW);

    const aPos = gl.getAttribLocation(program, 'position');
    const aUv  = gl.getAttribLocation(program, 'uv');
    const uTime = gl.getUniformLocation(program, 'time');
    const uRes  = gl.getUniformLocation(program, 'resolution');

    function resize(){
      const dpr = Math.min(window.devicePixelRatio || 1, 2);
      const w = Math.floor(window.innerWidth * dpr);
      const h = Math.floor(window.innerHeight * dpr);
      canvas.width = w; canvas.height = h;
      canvas.style.width = window.innerWidth + 'px';
      canvas.style.height = window.innerHeight + 'px';
      gl.viewport(0, 0, w, h);
    }
    window.addEventListener('resize', resize); resize();

    let start = performance.now();
    function render(now){
      const t = (now - start) * 0.001;
      gl.clearColor(0.06,0.08,0.12,1.0); gl.clear(gl.COLOR_BUFFER_BIT);
      gl.useProgram(program);
      gl.uniform1f(uTime, t);
      gl.uniform2f(uRes, canvas.width, canvas.height);
      gl.bindBuffer(gl.ARRAY_BUFFER, posBuf); gl.enableVertexAttribArray(aPos); gl.vertexAttribPointer(aPos,3,gl.FLOAT,false,0,0);
      gl.bindBuffer(gl.ARRAY_BUFFER, uvBuf);  gl.enableVertexAttribArray(aUv);  gl.vertexAttribPointer(aUv,2,gl.FLOAT,false,0,0);
      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
      requestAnimationFrame(render);
    }
    requestAnimationFrame(render);
  </script>
</body>
</html>
