<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Shadertoy WcffDN (port harness) â€” 12s</title>
  <style>html,body{height:100%;margin:0;background:#0a0c10}canvas{display:block;width:100%;height:100%}</style>
</head>
<body>
<canvas id="c"></canvas>

<script id="vs" type="x-shader/x-vertex">attribute vec2 aPos; varying vec2 vUv; void main(){ vUv=aPos*0.5+0.5; gl_Position=vec4(aPos,0.0,1.0);} </script>

<script id="fs" type="x-shader/x-fragment">
precision mediump float; varying vec2 vUv; uniform vec2 uRes; uniform float uTime; uniform float uPhase; const float TAU=6.2831853; const float PERIOD=12.0;

// Shadertoy compatibility layer (faithful iTime; uPhase left for optional looping experiments)
#define iResolution vec3(uRes, 0.0)
#define iTime (uTime)

// Helper functions and mainImage ported from the user's ShaderToy snippet
vec2 hash22(vec2 p) {
  vec3 p3 = fract(vec3(p.xyx) * vec3(123.34, 234.34, 345.65));
  p3 += dot(p3, p3 + 34.45);
  return fract(vec2(p3.x * p3.y, p3.y * p3.z));
}

float smin(float a, float b, float k) {
  float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);
  return mix(b, a, h) - k * h * (1.0 - h);
}

float voronoi(vec2 uv, float size) {
  float speed = 0.7;
  vec2 gv = fract(uv * size*4.0) - 0.5;
  vec2 id = floor(uv * size*4.0);
  float minDist = 1.0;
  for(float y = -1.0; y <= 1.0; y++) {
    for(float x = -1.0; x <= 1.0; x++) {
      vec2 offset = vec2(x, y);
      vec2 n = hash22(id + offset);
      vec2 p = offset + sin(n * (iTime * speed + 10.0)) * 0.5;
      float d = length(gv - p);
      minDist = smin(d, minDist, 0.5);
    }
  }
  return minDist;
}

float waves(vec2 uv) {
  float offset = (sin(uv.x * 10.0) * sin(uv.y * 10.0)) * 0.05;
  float noise = voronoi(uv + offset, 7.0);
  noise = smoothstep(0.5, 0.3, noise);
  return step(abs(noise - 0.5), 0.2);
}

void mainImage(out vec4 fragColor, in vec2 fragCoord) {
  vec2 uv = fragCoord / iResolution.xy - 0.5;
  uv.x *= iResolution.x / iResolution.y;
  uv.x += iTime * 0.01;
  float foam = waves(uv);
  float shadow = 1.0 - waves(uv + vec2(0.05)) * 0.4;
  vec3 water = vec3(0.4, 0.6, 0.9);
  water *= shadow;
  vec3 col = mix(water, vec3(0.95), foam);
  fragColor = vec4(col, 1.0);
}

void main(){ vec4 col; mainImage(col, vUv*uRes); gl_FragColor = col; }
</script>

<script>
function createShader(gl, src, type){ const s=gl.createShader(type); gl.shaderSource(s,src); gl.compileShader(s); if(!gl.getShaderParameter(s,gl.COMPILE_STATUS)){ console.error(gl.getShaderInfoLog(s)); gl.deleteShader(s); return null;} return s; }
function createProgram(gl, vsSrc, fsSrc){ const vs=createShader(gl,vsSrc,gl.VERTEX_SHADER); const fs=createShader(gl,fsSrc,gl.FRAGMENT_SHADER); if(!vs||!fs) return null; const p=gl.createProgram(); gl.attachShader(p,vs); gl.attachShader(p,fs); gl.bindAttribLocation(p,0,'aPos'); gl.linkProgram(p); if(!gl.getProgramParameter(p,gl.LINK_STATUS)){ console.error(gl.getProgramInfoLog(p)); return null;} return p; }
const canvas=document.getElementById('c'); const gl=canvas.getContext('webgl',{antialias:true}); if(!gl) throw new Error('WebGL not supported');
const prog=createProgram(gl,document.getElementById('vs').textContent,document.getElementById('fs').textContent); const uRes=gl.getUniformLocation(prog,'uRes'); const uTime=gl.getUniformLocation(prog,'uTime'); const uPhase=gl.getUniformLocation(prog,'uPhase');
const vb=gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER,vb); gl.bufferData(gl.ARRAY_BUFFER,new Float32Array([-1,-1, 1,-1, -1,1, 1,1]),gl.STATIC_DRAW);
let __fi_buffer=[]; const FI_MAX=16; function pushDt(dt){ __fi_buffer.push(dt); if(__fi_buffer.length>FI_MAX) __fi_buffer.shift(); }
function autoScale(){ if(__fi_buffer.length<6) return 1.0; const a=__fi_buffer.slice().sort((x,y)=>x-y); const med=a[Math.floor(a.length/2)]; const fps=1.0/med; const target=50; let s=fps/target; return Math.max(0.5, Math.min(1.0, s)); }
const MIN_DT=1/140, PERIOD=12.0;
function resizeCanvas(scale){ const dpr=Math.max(1,Math.min(window.devicePixelRatio||1,scale)); const w=Math.floor(window.innerWidth*dpr+0.5), h=Math.floor(window.innerHeight*dpr+0.5); if(canvas.width!==w||canvas.height!==h){ canvas.width=w; canvas.height=h; canvas.style.width=window.innerWidth+'px'; canvas.style.height=window.innerHeight+'px'; gl.viewport(0,0,w,h);} }
let last=performance.now(), start=last;
function frame(now){ now=performance.now(); let dt=(now-last)/1000; if(dt<MIN_DT){ requestAnimationFrame(frame); return;} last=now; pushDt(dt);
  const s=autoScale(); const dprCap=Math.max(1,Math.min(window.devicePixelRatio||1,1.0)); resizeCanvas(Math.min(dprCap,s));
  gl.useProgram(prog); gl.bindBuffer(gl.ARRAY_BUFFER,vb); gl.enableVertexAttribArray(0); gl.vertexAttribPointer(0,2,gl.FLOAT,false,0,0);
  gl.uniform2f(uRes,canvas.width,canvas.height);
  const t=(now-start)/1000.0; // seconds since load
  gl.uniform1f(uTime,t);
  gl.uniform1f(uPhase,(t%PERIOD)/PERIOD); // still exposed if you want a looped phase
  gl.drawArrays(gl.TRIANGLE_STRIP,0,4); requestAnimationFrame(frame);
}
window.addEventListener('resize',()=>resizeCanvas(autoScale())); resizeCanvas(1.0); requestAnimationFrame(()=>{ last=performance.now(); start=last; requestAnimationFrame(frame);});
</script>

</body>
</html>
