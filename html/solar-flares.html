<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Solar Flares â€” 15s</title>
  <style>
    html,body{height:100%;margin:0;background:#0b0a08}
    canvas{display:block;width:100%;height:100%}
  </style>
</head>
<body>
<canvas id="c"></canvas>

<script id="vs" type="x-shader/x-vertex">attribute vec2 aPos; varying vec2 vUv; void main(){ vUv=aPos*0.5+0.5; gl_Position=vec4(aPos,0.0,1.0);} </script>

<script id="fs" type="x-shader/x-fragment">
precision mediump float;
varying vec2 vUv;
uniform vec2 uRes;
uniform float uPhase;

const float TAU = 6.2831853;

// Cheap pseudo-granulation using a few sines; tileable via integer cycles
float gran(vec2 p, float t){
  float g = 0.0;
  g += 0.5 + 0.5*sin(6.0*p.x + 3.5*p.y + TAU*1.0*t);
  g += 0.5 + 0.5*sin(4.2*p.x - 5.1*p.y - TAU*2.0*t + 1.7);
  g += 0.5 + 0.5*sin(-3.7*p.x + 2.8*p.y + TAU*3.0*t + 0.4);
  return g/3.0; // 0..1
}

void main(){
  // Square aspect coords
  vec2 p = (vUv*uRes - 0.5*uRes)/min(uRes.x,uRes.y);
  float r = length(p);
  float th = atan(p.y, p.x);

  // Core rotation: 1 turn per loop for seamless wrap
  float rot = TAU * 1.0 * uPhase;
  th += 0.15*sin(TAU*2.0*uPhase) + 0.12*sin(TAU*3.0*uPhase + 0.7); // subtle wobble

  // Flares: bright arcs gated by angle and radius, with integer temporal multipliers
  float arcs = 0.0;
  arcs += smoothstep(0.94, 1.0, 0.5 + 0.5*cos(6.0*(th+rot) - TAU*1.0*uPhase)) * smoothstep(0.15, 0.05, r);
  arcs += smoothstep(0.90, 1.0, 0.5 + 0.5*cos(9.0*(th+rot) - TAU*2.0*uPhase + 0.8)) * smoothstep(0.28, 0.10, r);
  arcs += smoothstep(0.90, 1.0, 0.5 + 0.5*cos(12.0*(th+rot) - TAU*3.0*uPhase + 1.6)) * smoothstep(0.42, 0.16, r);
  arcs = clamp(arcs, 0.0, 1.0);

  // Radial hot shell
  float shell = exp(-pow((r-0.22)/0.18, 2.0))*0.9 + exp(-pow((r-0.45)/0.22, 2.0))*0.6;

  // Granulation
  float g = gran(p*3.0, uPhase);

  // Combine energy field
  float energy = clamp(0.55*arcs + 0.45*shell + 0.25*g*(1.0-r), 0.0, 1.0);

  // Color ramp: deep ember -> orange -> white-hot
  vec3 deep = vec3(0.08,0.03,0.01);
  vec3 hotA = vec3(1.00,0.45,0.05);
  vec3 hotB = vec3(1.00,0.95,0.80);
  vec3 col = mix(deep, hotA, pow(energy,0.9));
  col = mix(col, hotB, smoothstep(0.78, 1.0, energy));

  // Bloom near arcs and core
  float glow = exp(-r*1.5) * (0.3 + 0.7*pow(energy,1.6));
  col += glow * vec3(1.0,0.6,0.2) * 0.35;

  // Vignette
  col *= mix(0.86, 1.0, smoothstep(1.15, 0.2, r));

  gl_FragColor = vec4(clamp(col,0.0,1.0), 1.0);
}
</script>

<script>
// Minimal helpers
function createShader(gl, src, type){ const s=gl.createShader(type); gl.shaderSource(s,src); gl.compileShader(s); if(!gl.getShaderParameter(s,gl.COMPILE_STATUS)){ console.error(gl.getShaderInfoLog(s)); gl.deleteShader(s); return null;} return s; }
function createProgram(gl, vsSrc, fsSrc){ const vs=createShader(gl,vsSrc,gl.VERTEX_SHADER); const fs=createShader(gl,fsSrc,gl.FRAGMENT_SHADER); if(!vs||!fs) return null; const p=gl.createProgram(); gl.attachShader(p,vs); gl.attachShader(p,fs); gl.bindAttribLocation(p,0,'aPos'); gl.linkProgram(p); if(!gl.getProgramParameter(p,gl.LINK_STATUS)){ console.error(gl.getProgramInfoLog(p)); return null;} return p; }

const canvas = document.getElementById('c');
const gl = canvas.getContext('webgl', {antialias:true});
if(!gl) throw new Error('WebGL not supported');

const prog = createProgram(gl, document.getElementById('vs').textContent, document.getElementById('fs').textContent);
const uRes = gl.getUniformLocation(prog,'uRes');
const uPhase = gl.getUniformLocation(prog,'uPhase');

// fullscreen quad
const vb = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, vb); gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1, 1,1]), gl.STATIC_DRAW);

// adaptive scaler
let __fi_buffer=[]; const FI_MAX=16; function pushDt(dt){ __fi_buffer.push(dt); if(__fi_buffer.length>FI_MAX) __fi_buffer.shift(); }
function autoScale(){ if(__fi_buffer.length<6) return 1.0; const a=__fi_buffer.slice().sort((x,y)=>x-y); const med=a[Math.floor(a.length/2)]; const fps=1.0/med; const target=50; let s=fps/target; return Math.max(0.5, Math.min(1.0, s)); }
const MIN_DT = 1/140; // pacing guard
const PERIOD = 15.0;  // forward-only, seamless via periodic sin/cos

function resizeCanvas(scale){ const dpr = Math.max(1, Math.min(window.devicePixelRatio||1, scale)); const w=Math.floor(window.innerWidth*dpr+0.5), h=Math.floor(window.innerHeight*dpr+0.5); if(canvas.width!==w||canvas.height!==h){ canvas.width=w; canvas.height=h; canvas.style.width=window.innerWidth+'px'; canvas.style.height=window.innerHeight+'px'; gl.viewport(0,0,w,h);} }

let last=performance.now(), start=last;
function frame(now){ now=performance.now(); let dt=(now-last)/1000; if(dt<MIN_DT){ requestAnimationFrame(frame); return; } last=now; pushDt(dt);
  const s=autoScale(); const dprCap=Math.max(1, Math.min(window.devicePixelRatio||1, 1.0)); const scale=Math.min(dprCap, s); resizeCanvas(scale);
  const w=canvas.width, h=canvas.height;
  gl.useProgram(prog);
  gl.bindBuffer(gl.ARRAY_BUFFER, vb); gl.enableVertexAttribArray(0); gl.vertexAttribPointer(0,2,gl.FLOAT,false,0,0);
  gl.uniform2f(uRes, w, h);
  const t=(now-start)/1000.0;
  const phase = (t % PERIOD) / PERIOD; // [0,1) forward-only
  gl.uniform1f(uPhase, phase);
  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
  requestAnimationFrame(frame);
}

window.addEventListener('resize', ()=>resizeCanvas(autoScale()));
resizeCanvas(1.0);
requestAnimationFrame(()=>{ last=performance.now(); start=last; requestAnimationFrame(frame); });
</script>

</body>
</html>
