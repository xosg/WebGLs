<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Infinite Tunnel Illusion</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
        }
        canvas {
            width: 100vw;
            height: 100vh;
            display: block;
        }
    </style>
</head>
<body>
    <canvas id="tunnel"></canvas>
    <script type="x-shader/x-vertex" id="vertexShader">
        attribute vec3 position;
        attribute vec2 uv;
        
        varying vec2 vUv;
        
        void main() {
            vUv = uv;
            gl_Position = vec4(position, 1.0);
        }
    </script>
    
    <script type="x-shader/x-fragment" id="fragmentShader">
        #ifdef GL_FRAGMENT_PRECISION_HIGH
        precision highp float;
        #else
        precision mediump float;
        #endif
        
        varying vec2 vUv;
        uniform float time;
        uniform vec2 resolution;
        uniform vec2 mouse;
        
        // Helper for nice coloring
        vec3 palette(float t) {
            return 0.5 + 0.5 * cos(6.28318 * (vec3(0.0, 0.33, 0.67) + t));
        }
        
    void main() {
            // Normalize pixel coords to -1..1 with aspect
            vec2 p = vUv * 2.0 - 1.0;
            p.x *= resolution.x / resolution.y;
            
            // Mouse influence (-0.5..0.5)
            vec2 mp = (mouse - 0.5) * 1.0;
            
            float a = atan(p.y, p.x) + mp.x * 1.2;
            float r = length(p) * (1.0 + mp.y * 0.8);
            
            // Wrap global time to keep phases in a stable range (prevents precision loss)
            float timeWrap = mod(time, 628.3185307); // ~200*pi

            // Tunnel bands
            float v = 0.0;
            const int ITER = 3;
            for (int i = 0; i < ITER; i++) {
                float fi = float(i);
                float t = timeWrap * (1.0 - 0.18 * fi);
                t = mod(t, 6.28318530718); // keep near [-pi..pi]
                v += 0.5 * sin(a * 5.0 + fi * 3.14159265 + t);
                v += 0.5 * cos(r * 10.0 - t + fi);
            }
            v = v / float(ITER);

            // Use bounded phase for color drift to avoid large-argument artifacts
            float colPhase = sin(time * 0.1);
            vec3 col = palette(v + colPhase);
            col *= smoothstep(1.2, 0.0, r); // vignette
            
            gl_FragColor = vec4(col, 1.0);
        }
    </script>

    <script>
        const canvas = document.getElementById('tunnel');
        const gl = canvas.getContext('webgl');

        if (!gl) {
            alert('WebGL not supported');
            throw new Error('WebGL not supported');
        }

        // Compile shaders
        function createShader(type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error(gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        const vertexShader = createShader(
            gl.VERTEX_SHADER,
            document.getElementById('vertexShader').textContent
        );

        const fragmentShader = createShader(
            gl.FRAGMENT_SHADER,
            document.getElementById('fragmentShader').textContent
        );

        // Create program
        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);

        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            console.error(gl.getProgramInfoLog(program));
            throw new Error('Program link failed');
        }

        // Set up geometry
        const positions = new Float32Array([
            -1, -1, 0,
             1, -1, 0,
            -1,  1, 0,
             1,  1, 0
        ]);

        const uvs = new Float32Array([
            0, 0,
            1, 0,
            0, 1,
            1, 1
        ]);

        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

        const uvBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, uvBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, uvs, gl.STATIC_DRAW);

        // Get attribute locations
        const positionLocation = gl.getAttribLocation(program, 'position');
        const uvLocation = gl.getAttribLocation(program, 'uv');

        // Get uniform locations
        const timeLocation = gl.getUniformLocation(program, 'time');
        const resolutionLocation = gl.getUniformLocation(program, 'resolution');
        const mouseLocation = gl.getUniformLocation(program, 'mouse');

        // Animation state
        let time = 0;
        const mouse = { x: 0.5, y: 0.5 };

        // Handle mouse movement (normalized 0..1 using CSS size)
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            mouse.x = (e.clientX - rect.left) / rect.width;
            mouse.y = (e.clientY - rect.top) / rect.height;
        });

        // Handle resize
        function resize() {
            const dpr = Math.min(window.devicePixelRatio || 1, 2);
            const w = Math.floor(window.innerWidth * dpr);
            const h = Math.floor(window.innerHeight * dpr);
            canvas.width = w;
            canvas.height = h;
            canvas.style.width = window.innerWidth + 'px';
            canvas.style.height = window.innerHeight + 'px';
            gl.viewport(0, 0, w, h);
        }
        window.addEventListener('resize', resize);
        resize();

        // Render loop
        let start = performance.now();
        function render(now) {
            time = (now - start) * 0.001;

            gl.clearColor(0, 0, 0, 1);
            gl.clear(gl.COLOR_BUFFER_BIT);

            gl.useProgram(program);

            // Set uniforms
            gl.uniform1f(timeLocation, time);
            gl.uniform2f(resolutionLocation, canvas.width, canvas.height);
            gl.uniform2f(mouseLocation, mouse.x, mouse.y);

            // Set attributes
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.enableVertexAttribArray(positionLocation);
            gl.vertexAttribPointer(positionLocation, 3, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, uvBuffer);
            gl.enableVertexAttribArray(uvLocation);
            gl.vertexAttribPointer(uvLocation, 2, gl.FLOAT, false, 0, 0);

            // Draw
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

            requestAnimationFrame(render);
        }

        requestAnimationFrame(render);
    </script>
</body>
</html>
